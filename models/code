# app.py

import streamlit as st
import pandas as pd
import numpy as np
import itertools
import plotly.graph_objects as go
import plotly.express as px

from arch import arch_model
from scipy.stats import genpareto
from hmmlearn.hmm import GaussianHMM

# ────────────────────────────────────────────────────────────────────────────────
# UTILITY FUNCTIONS
# ────────────────────────────────────────────────────────────────────────────────

SQRT252 = np.sqrt(252)
MANUAL_BANDS = {
    'Low':      (0.00, 0.07),
    'Medium':   (0.07, 0.50),
    'High':     (0.50, 0.60),
    'VeryHigh': (0.60, None)
}

def compute_manual_groups(df):
    df2 = df.copy()
    df2['DailyVol'] = df2['OHLCVolatility'] / SQRT252
    mean_vol = (
        df2.groupby('Currency')['DailyVol']
           .mean()
           .reset_index(name='MeanDailyVol')
    )
    def assign_band(v):
        for b,(lo,hi) in MANUAL_BANDS.items():
            if hi is None and v>=lo: return b
            if lo<=v<hi:            return b
        return None
    mean_vol['Band'] = mean_vol['MeanDailyVol'].map(assign_band)
    band_thr = (
        mean_vol.groupby('Band')['MeanDailyVol']
                .max()
                .reset_index(name='BandThreshold')
    )
    return mean_vol, band_thr

def rolling_quantile(vol, window, q):
    return vol.rolling(window).quantile(q)

def garch_evt(returns, tail_pct):
    am  = arch_model(returns*100, vol='Garch', p=1, q=1)
    res = am.fit(disp='off')
    std = res.resid / res.conditional_volatility
    std = std[np.isfinite(std)]
    u   = np.quantile(std, 0.90)
    exc = std[std>u] - u
    c,loc,scale = genpareto.fit(exc, floc=0)
    p_exc = (tail_pct - (1 - np.mean(std>u))) / np.mean(std>u)
    var   = genpareto.ppf(p_exc, c, loc=0, scale=scale)
    return (u + var)/100.0

def detect_regimes(vol: pd.Series, n_states: int):
    """
    Fit an HMM to vol (drop NaN/Inf), return:
      - full-length state array aligned to vol.index
      - label of the 'high-vol' regime
      - mean vol of that high-vol regime
    """
    clean = vol.replace([np.inf,-np.inf], np.nan).dropna()
    if clean.empty:
        return np.zeros(len(vol),int), 0, np.nan

    arr = clean.values.reshape(-1,1)
    model = GaussianHMM(n_components=n_states,
                        covariance_type='full',
                        n_iter=200)
    model.fit(arr)
    raw = model.predict(arr)
    means = {s: arr[raw==s].mean() for s in np.unique(raw)}
    high  = max(means, key=means.get)

    # map back to full index, ffill/bfill
    s = pd.Series(raw, index=clean.index)
    full = s.reindex(vol.index).fillna(method='ffill').fillna(method='bfill').astype(int)
    return full.values, high, means[high]

def smooth_regimes(raw_states: np.ndarray, min_run: int = 5) -> np.ndarray:
    """
    Collapse any contiguous run shorter than `min_run` days into neighbors.
    """
    s = pd.Series(raw_states)
    runs    = (s != s.shift()).cumsum()
    lengths = s.groupby(runs).transform('size')
    s[lengths < min_run] = np.nan
    return s.ffill().bfill().astype(int).values

def calibrate_regime(vol, lr, target, windows, qs, tails):
    best_wq = min(
        ((abs((vol>rolling_quantile(vol,w,q)).mean() - target),(w,q))
         for w,q in itertools.product(windows,qs)),
        key=lambda x:x[0]
    )[1]
    best_t = min(
        ((abs((vol>garch_evt(lr,t)).mean() - target), t)
         for t in tails),
        key=lambda x:x[0]
    )[1]
    return {'window':best_wq[0],'quantile':best_wq[1],'tail':best_t}


# ────────────────────────────────────────────────────────────────────────────────
# STREAMLIT APP START
# ────────────────────────────────────────────────────────────────────────────────

st.set_page_config(page_title="FX Threshold & Regimes", layout="wide")
st.title("📊 FX Vol Threshold & Regime‐Shift Dashboard")

# ─ Sidebar: Data & Params ────────────────────────────────────────────────────────
st.sidebar.header("1️⃣ Upload FX Data")
f = st.sidebar.file_uploader(
    "CSV with Date,Open,High,Low,Close,OHLCVolatility,Currency",
    type="csv"
)
if not f:
    st.sidebar.info("Please upload your FX dataset.")
    st.stop()

df = pd.read_csv(f, parse_dates=['Date']).sort_values(['Currency','Date'])
df['DailyVol'] = df['OHLCVolatility'] / SQRT252

mean_vol_df, band_thr_df = compute_manual_groups(df)

# Cross selection
cross_df = df.pivot(index='Date', columns='Currency', values='DailyVol')
crosses  = sorted([
    f"{b}/{q}" for i,b in enumerate(cross_df.columns)
     for q in cross_df.columns[i+1:]
])
sel_cross = st.sidebar.selectbox("2️⃣ Select FX Cross", crosses)
base_cc, quote_cc = sel_cross.split('/')

# HMM states
n_states = st.sidebar.slider("3️⃣ Number of Regimes (HMM States)", 2, 4, 2)

# Calibration
st.sidebar.header("4️⃣ Calibration Targets")
target_rate  = st.sidebar.slider("Target Alert Rate", 0.01,0.20,0.05,0.01)
roll_windows = [30,60,90,120]
roll_qs      = [0.90,0.95,0.99]
evt_tails    = [0.990,0.995,0.999]

# Tiers & consensus
st.sidebar.header("5️⃣ Multi‐Tier & Consensus")
tiers     = st.sidebar.multiselect(
    "Show Tiers",
    ['Warning (90%)','Alert (95%)','Critical (EVT)'],
    default=['Alert (95%)']
)
cons_frac = st.sidebar.slider("Consensus Fraction", 0.1,1.0,0.5,0.05)

# ────────────────────────────────────────────────────────────────────────────────
# PREPARE TIME SERIES
# ────────────────────────────────────────────────────────────────────────────────
base_ser  = df[df.Currency==base_cc].set_index('Date')['DailyVol']
quote_ser = df[df.Currency==quote_cc].set_index('Date')['DailyVol']
common    = base_ser.index.intersection(quote_ser.index)

cross_vol = np.sqrt(base_ser.loc[common]**2 + quote_ser.loc[common]**2)
cross_lr  = np.log(
    df[df.Currency==quote_cc].set_index('Date')['Close'].loc[common] /
    df[df.Currency==base_cc].set_index('Date')['Close'].loc[common]
)

# detect + smooth regimes
raw_b, high_b, thr_b = detect_regimes(base_ser,  n_states)
raw_q, high_q, thr_q = detect_regimes(quote_ser, n_states)
raw_x, high_x, thr_x = detect_regimes(cross_vol,  n_states)

states_b = smooth_regimes(raw_b, min_run=5)
states_q = smooth_regimes(raw_q, min_run=5)
states_x = smooth_regimes(raw_x, min_run=5)

# build DataFrames
df_base  = pd.DataFrame({'Date':base_ser.index,  'Vol':base_ser.values,  'Regime':states_b})
df_quote = pd.DataFrame({'Date':quote_ser.index,'Vol':quote_ser.values,'Regime':states_q})
df_cross = pd.DataFrame({'Date':common,        'Vol':cross_vol.values,'Regime':states_x})

for ddf in (df_base, df_quote, df_cross):
    ddf['RegLabel'] = ddf.Regime.map(lambda s: f"Regime {s}")

chg_b = df_base.Regime.ne(df_base.Regime.shift())
chg_q = df_quote.Regime.ne(df_quote.Regime.shift())
chg_x = df_cross.Regime.ne(df_cross.Regime.shift())

# ────────────────────────────────────────────────────────────────────────────────
# THRESHOLD DASHBOARD PREP
# ────────────────────────────────────────────────────────────────────────────────
dfc = df_cross.copy().set_index('Date')
mv = mean_vol_df.set_index('Currency')['MeanDailyVol']
mb1,mb2 = mean_vol_df.set_index('Currency')['Band'][[base_cc,quote_cc]]
order   = ['Low','Medium','High','VeryHigh']
man_band= mb1 if order.index(mb1)>order.index(mb2) else mb2
man_thr = band_thr_df.set_index('Band')['BandThreshold'][man_band]

# per-regime calibration
calib = {
    r: calibrate_regime(
        grp['Vol'],
        np.log(grp['Vol']/grp['Vol'].shift(1)).dropna(),
        target_rate, roll_windows, roll_qs, evt_tails
    )
    for r,grp in df_cross.groupby('Regime')
}

dfc['Thr_Warning'] = np.nan
dfc['Thr_Alert']   = np.nan

for r,grp in dfc.groupby('Regime'):
    w,q = calib[r]['window'], calib[r]['quantile']
    dfc.loc[grp.index,'Thr_Warning'] = rolling_quantile(grp['Vol'], w, 0.90)
    dfc.loc[grp.index,'Thr_Alert']   = rolling_quantile(grp['Vol'], w, q)

dfc['Thr_Critical'] = dfc.Regime.map(lambda r: garch_evt(
    np.log(dfc['Vol']/dfc['Vol'].shift(1)).dropna().values,
    calib[r]['tail']
))

cons_series = (((dfc['Vol']>dfc['Thr_Alert']).astype(int) +
                (dfc['Vol']>dfc['Thr_Critical']).astype(int)) / 2
               >= cons_frac)
cons_rate   = cons_series.mean()

# ────────────────────────────────────────────────────────────────────────────────
# TAB LAYOUT
# ────────────────────────────────────────────────────────────────────────────────
tabs = st.tabs([
    "📋 Overview",
    "🔢 Threshold Dashboard",
    f"⚙️ {base_cc} Regimes",
    f"⚙️ {quote_cc} Regimes",
    f"⚙️ {base_cc}/{quote_cc} Regimes"
])

# Overview
with tabs[0]:
    st.header("Why This Framework?")
    st.markdown("""
    - **Target Alert Rate** – tie alerts to your false‐alarm vs. missed‐alarm costs.  
    - **HMM Regimes** – automatically detect calm, normal, and stress states.  
    - **Per‐Regime Calibration** – fit rolling‐quantile & EVT tail in each state.  
    - **Multi‐Tier Alerts** – 90th (warning), 95th (alert), EVT tail (critical).  
    - **Consensus** – combine tier signals for robust, noise‐reduced alerts.
    """)

# Threshold Dashboard
with tabs[1]:
    st.header(f"🔢 Threshold Dashboard — {sel_cross}")
    c0,c1,c2,c3,c4,c5 = st.columns(6)
    c0.metric("Manual Thr",     f"{man_thr:.4f}")
    c1.metric("Latest Vol",     f"{dfc['Vol'].iat[-1]:.4f}")
    c2.metric("Warning Thr",    f"{dfc['Thr_Warning'].iat[-1]:.4f}")
    c3.metric("Alert Thr",      f"{dfc['Thr_Alert'].iat[-1]:.4f}")
    c4.metric("Critical Thr",   f"{dfc['Thr_Critical'].iat[-1]:.4f}")
    c5.metric("Consensus Rate", f"{cons_rate:.1%}")
    st.markdown("KPI cards compare current vol vs each tier and show consensus‐based breach rate.")

    fig = go.Figure()
    fig.add_trace(go.Scatter(x=dfc.index, y=dfc['Vol'], name='Volatility'))
    if 'Warning (90%)' in tiers:
        fig.add_trace(go.Scatter(x=dfc.index, y=dfc['Thr_Warning'],
                                 name='Warning (90%)', line=dict(dash='dash')))
    if 'Alert (95%)' in tiers:
        fig.add_trace(go.Scatter(x=dfc.index, y=dfc['Thr_Alert'],
                                 name='Alert (95%)', line=dict(dash='dot')))
    if 'Critical (EVT)' in tiers:
        fig.add_trace(go.Scatter(x=dfc.index, y=dfc['Thr_Critical'],
                                 name='Critical (EVT)', line=dict(dash='longdash')))
    fig.update_layout(
        title="Volatility vs. Multi-Tier Thresholds",
        xaxis=dict(rangeslider=dict(visible=True)),
        yaxis_title="Daily Volatility",
        height=450
    )
    st.plotly_chart(fig, use_container_width=True)
    st.markdown("Overlay chart: how actual volatility stacks up against your tiers over time.")

    breach = {
        'Warning': (dfc['Vol']>dfc['Thr_Warning']).mean(),
        'Alert':   (dfc['Vol']>dfc['Thr_Alert']).mean(),
        'Critical':(dfc['Vol']>dfc['Thr_Critical']).mean()
    }
    st.bar_chart(pd.Series(breach, name='Breach Rate'))
    st.markdown("Breach‐rate bar: % days each tier would have fired.")

# Base Regimes
with tabs[2]:
    st.header(f"{base_cc} Regime Shifts")
    fig_b = px.line(df_base, x='Date', y='Vol', color='RegLabel',
                    labels={'Vol':'Daily Volatility'})
    for d in df_base.loc[chg_b,'Date']:
        fig_b.add_vline(x=d, line_dash='dash', line_color='red', opacity=0.6)
    fig_b.update_layout(title=f"{base_cc} Volatility by Regime")
    st.plotly_chart(fig_b, use_container_width=True)
    st.markdown("""
    Daily volatility colored by HMM regime.  
    Red dashed lines mark regime‐change dates (min 5-day runs), highlighting calm→stress transitions.
    """)

# Quote Regimes
with tabs[3]:
    st.header(f"{quote_cc} Regime Shifts")
    fig_q = px.line(df_quote, x='Date', y='Vol', color='RegLabel',
                    labels={'Vol':'Daily Volatility'})
    for d in df_quote.loc[chg_q,'Date']:
        fig_q.add_vline(x=d, line_dash='dash', line_color='green', opacity=0.6)
    fig_q.update_layout(title=f"{quote_cc} Volatility by Regime")
    st.plotly_chart(fig_q, use_container_width=True)
    st.markdown("""
    Quote currency daily volatility by regime.  
    Green dashed lines indicate regime shifts after smoothing out short blips.
    """)

# Cross Regimes
with tabs[4]:
    st.header(f"{base_cc}/{quote_cc} Cross Regime Shifts")
    fig_x = px.line(df_cross, x='Date', y='Vol', color='RegLabel',
                    labels={'Vol':'Daily Volatility'})
    for d in df_cross.loc[chg_x,'Date']:
        fig_x.add_vline(x=d, line_dash='dash', line_color='black', opacity=0.6)
    # overlay base & quote
    for d in df_base.loc[chg_b & df_base.Date.isin(df_cross.Date),'Date']:
        fig_x.add_vline(x=d, line_dash='dot', line_color='red', opacity=0.4)
    for d in df_quote.loc[chg_q & df_quote.Date.isin(df_cross.Date),'Date']:
        fig_x.add_vline(x=d, line_dash='dot', line_color='green', opacity=0.4)
    fig_x.add_trace(go.Scatter(x=[None],y=[None],mode='lines',
        line=dict(color='red', dash='dot'), name=f"{base_cc} Change"))
    fig_x.add_trace(go.Scatter(x=[None],y=[None],mode='lines',
        line=dict(color='green', dash='dot'), name=f"{quote_cc} Change"))
    fig_x.update_layout(title=f"{base_cc}/{quote_cc} Cross Volatility by Regime")
    st.plotly_chart(fig_x, use_container_width=True)
    st.markdown("""
    Cross daily volatility by regime (black dashed = cross changes).  
    Red/green dotted lines show exactly when base or quote switched regimes—revealing which leg drove the cross move.
    """)
