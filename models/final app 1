# app.py

import streamlit as st
import pandas as pd
import numpy as np
import itertools
import plotly.graph_objects as go
import plotly.express as px

from arch import arch_model
from scipy.stats import genpareto
from hmmlearn.hmm import GaussianHMM

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# UTILITY FUNCTIONS
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

SQRT252 = np.sqrt(252)
MANUAL_BANDS = {
    'Low':      (0.00, 0.07),
    'Medium':   (0.07, 0.50),
    'High':     (0.50, 0.60),
    'VeryHigh': (0.60, None)
}

def compute_manual_groups(df):
    df2 = df.copy()
    df2['DailyVol'] = df2['OHLCVolatility'] / SQRT252
    mean_vol = (df2.groupby('Currency')['DailyVol']
                  .mean().reset_index(name='MeanDailyVol'))
    def assign_band(v):
        for b,(lo,hi) in MANUAL_BANDS.items():
            if hi is None and v>=lo: return b
            if lo<=v<hi:            return b
        return None
    mean_vol['Band'] = mean_vol['MeanDailyVol'].map(assign_band)
    band_thr = (mean_vol.groupby('Band')['MeanDailyVol']
                      .max().reset_index(name='BandThreshold'))
    return mean_vol, band_thr

def rolling_quantile(vol, window, q):
    return vol.rolling(window).quantile(q)

def garch_evt(returns, tail_pct):
    am  = arch_model(returns*100, vol='Garch', p=1, q=1)
    res = am.fit(disp='off')
    std = res.resid / res.conditional_volatility
    std = std[np.isfinite(std)]
    u   = np.quantile(std, 0.90)
    exc = std[std>u] - u
    c,loc,scale = genpareto.fit(exc, floc=0)
    p_exc = (tail_pct - (1 - np.mean(std>u))) / np.mean(std>u)
    var   = genpareto.ppf(p_exc, c, loc=0, scale=scale)
    return (u + var)/100.0

def detect_regimes(vol, n_states):
    clean = vol.replace([np.inf,-np.inf], np.nan).dropna()
    if clean.empty:
        return np.zeros(len(vol),int), 0, np.nan
    arr = clean.values.reshape(-1,1)
    model = GaussianHMM(n_components=n_states, covariance_type='full', n_iter=200)
    model.fit(arr)
    raw = model.predict(arr)
    means = {s: arr[raw==s].mean() for s in np.unique(raw)}
    high  = max(means, key=means.get)
    ser = pd.Series(raw, index=clean.index)
    full = ser.reindex(vol.index).fillna(method='ffill').fillna(method='bfill').astype(int)
    return full.values, high, means[high]

def calibrate_regime(vol, lr, target, windows, qs, tails):
    best_wq = min(
      ((abs((vol>rolling_quantile(vol,w,q)).mean() - target),(w,q))
       for w,q in itertools.product(windows,qs)),
      key=lambda x:x[0]
    )[1]
    best_t = min(
      ((abs((vol>garch_evt(lr,t)).mean() - target), t)
       for t in tails),
      key=lambda x:x[0]
    )[1]
    return {'window':best_wq[0],'quantile':best_wq[1],'tail':best_t}

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# APP LAYOUT
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

st.set_page_config(page_title="FX Threshold & Regimes", layout="wide")
st.title("üìä FX Volatility: Threshold & Regime‚ÄìShift Dashboard")

# Sidebar
st.sidebar.header("1Ô∏è‚É£ Upload & Settings")
f = st.sidebar.file_uploader(
    "CSV with Date,Open,High,Low,Close,OHLCVolatility,Currency", type="csv"
)
if not f:
    st.sidebar.info("Upload your FX data to begin.")
    st.stop()

df = pd.read_csv(f, parse_dates=['Date']).sort_values(['Currency','Date'])
df['DailyVol'] = df['OHLCVolatility'] / SQRT252

# Manual grouping (for dashboard)
mean_vol_df, band_thr_df = compute_manual_groups(df)

# Cross selection
cross_df   = df.pivot(index='Date', columns='Currency', values='DailyVol')
crosses    = sorted([f"{b}/{q}" for i,b in enumerate(cross_df.columns)
                     for q in cross_df.columns[i+1:]])
sel_cross  = st.sidebar.selectbox("2Ô∏è‚É£ Select FX Cross", crosses)
base_cc, quote_cc = sel_cross.split('/')

# HMM regimes
n_states = st.sidebar.slider("3Ô∏è‚É£ HMM Regime States", 2, 4, 2)

# Calibration settings
st.sidebar.header("4Ô∏è‚É£ Calibration")
target_rate  = st.sidebar.slider("Target Alert Rate", 0.01,0.20,0.05,0.01)
roll_windows = [30,60,90,120]
roll_qs      = [0.90,0.95,0.99]
evt_tails    = [0.990,0.995,0.999]

# Tiers & consensus
st.sidebar.header("5Ô∏è‚É£ Tiers & Consensus")
tiers     = st.sidebar.multiselect("Show Tiers", ['Warning (90%)','Alert (95%)','Critical (EVT)'],
                                   default=['Alert (95%)'])
cons_frac = st.sidebar.slider("Consensus Fraction", 0.1,1.0,0.5,0.05)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Prepare DataSeries
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
base_ser  = df[df.Currency==base_cc].set_index('Date')['DailyVol']
quote_ser = df[df.Currency==quote_cc].set_index('Date')['DailyVol']
common    = base_ser.index.intersection(quote_ser.index)

cross_vol = (base_ser.loc[common]**2 + quote_ser.loc[common]**2)**0.5
cross_lr  = np.log(
    df[df.Currency==quote_cc].set_index('Date')['Close'].loc[common] /
    df[df.Currency==base_cc].set_index('Date')['Close'].loc[common]
)

states_b,high_b,thr_b = detect_regimes(base_ser,  n_states)
states_q,high_q,thr_q = detect_regimes(quote_ser, n_states)
states_x,high_x,thr_x = detect_regimes(cross_vol,  n_states)

df_base  = pd.DataFrame({'Date':base_ser.index,  'Vol':base_ser.values,  'Regime':states_b})
df_quote = pd.DataFrame({'Date':quote_ser.index,'Vol':quote_ser.values,'Regime':states_q})
df_cross = pd.DataFrame({'Date':common,        'Vol':cross_vol.values,'Regime':states_x})

for ddf in (df_base,df_quote,df_cross):
    ddf['RegLabel'] = ddf.Regime.map(lambda s:f"Regime {s}")

chg_b = df_base.Regime.ne(df_base.Regime.shift())
chg_q = df_quote.Regime.ne(df_quote.Regime.shift())
chg_x = df_cross.Regime.ne(df_cross.Regime.shift())

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Threshold Dashboard Prep
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
dfc = df_cross.copy().set_index('Date')
mv = mean_vol_df.set_index('Currency')['MeanDailyVol']
mb1 = mean_vol_df.set_index('Currency')['Band'][base_cc]
mb2 = mean_vol_df.set_index('Currency')['Band'][quote_cc]
order = ['Low','Medium','High','VeryHigh']
man_band = mb1 if order.index(mb1)>order.index(mb2) else mb2
man_thr  = band_thr_df.set_index('Band')['BandThreshold'][man_band]

# Per‚Äêregime calibration
calib = {
    r: calibrate_regime(
         grp['Vol'], np.log(grp['Vol']/grp['Vol'].shift(1)).dropna(),
         target_rate, roll_windows, roll_qs, evt_tails
       )
    for r,grp in df_cross.groupby('Regime')
}

# Compute tier thresholds
dfc['Thr_Warning'] = np.nan
dfc['Thr_Alert']   = np.nan
for r,grp in dfc.groupby('Regime'):
    w,q = calib[r]['window'], calib[r]['quantile']
    dfc.loc[grp.index,'Thr_Warning'] = rolling_quantile(grp['Vol'], w, 0.90)
    dfc.loc[grp.index,'Thr_Alert']   = rolling_quantile(grp['Vol'], w, q)
dfc['Thr_Critical'] = dfc.Regime.map(lambda r: garch_evt(
    np.log(dfc['Vol']/dfc['Vol'].shift(1)).dropna().values,
    calib[r]['tail']
))
cons_series = (((dfc['Vol']>dfc['Thr_Alert']).astype(int) +
                (dfc['Vol']>dfc['Thr_Critical']).astype(int))/2
               >= cons_frac)
cons_rate   = cons_series.mean()

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# TABS
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
tabs = st.tabs([
    "üìã Overview",
    "üî¢ Threshold Dashboard",
    f"‚öôÔ∏è {base_cc} Regimes",
    f"‚öôÔ∏è {quote_cc} Regimes",
    f"‚öôÔ∏è {base_cc}/{quote_cc} Regimes"
])

# Overview
with tabs[0]:
    st.header("Why This Framework?")
    st.markdown("""
    - **Target Alert Rate**: align alerts with your false‚Äêalarm vs. missed‚Äêalarm costs.  
    - **HMM Regimes**: detect calm, normal, and stress regimes automatically.  
    - **Per‚ÄêRegime Calibration**: fit rolling‚Äêquantile & EVT tail in each regime.  
    - **Multi‚ÄêTier Alerts**: 90th (warning), 95th (alert), EVT tail (critical).  
    - **Consensus**: combine alert signals for robust decision‚Äêmaking.
    """)

# Threshold Dashboard
with tabs[1]:
    st.header(f"Threshold Dashboard ‚Äî {sel_cross}")
    cols = st.columns(6)
    cols[0].metric("Manual Thr",     f"{man_thr:.4f}")
    cols[1].metric("Latest Vol",     f"{dfc['Vol'].iat[-1]:.4f}")
    cols[2].metric("Warning Thr",    f"{dfc['Thr_Warning'].iat[-1]:.4f}")
    cols[3].metric("Alert Thr",      f"{dfc['Thr_Alert'].iat[-1]:.4f}")
    cols[4].metric("Critical Thr",   f"{dfc['Thr_Critical'].iat[-1]:.4f}")
    cols[5].metric("Consensus Rate", f"{cons_rate:.1%}")
    st.markdown("**KPI cards** show current volatility vs. each tier threshold and the consensus‚Äêbased alert rate.")

    fig = go.Figure()
    fig.add_trace(go.Scatter(x=dfc.index, y=dfc['Vol'], name='Volatility'))
    if 'Warning (90%)' in tiers:
        fig.add_trace(go.Scatter(x=dfc.index, y=dfc['Thr_Warning'],
                                 name='Warning (90%)', line=dict(dash='dash')))
    if 'Alert (95%)' in tiers:
        fig.add_trace(go.Scatter(x=dfc.index, y=dfc['Thr_Alert'],
                                 name='Alert (95%)', line=dict(dash='dot')))
    if 'Critical (EVT)' in tiers:
        fig.add_trace(go.Scatter(x=dfc.index, y=dfc['Thr_Critical'],
                                 name='Critical (EVT)', line=dict(dash='longdash')))
    fig.update_layout(
        xaxis=dict(rangeslider=dict(visible=True)),
        yaxis_title="Daily Volatility",
        height=450,
        title="Volatility vs. Multi‚ÄêTier Thresholds"
    )
    st.plotly_chart(fig, use_container_width=True)
    st.markdown("**Overlay chart**: how actual volatility compares to Warning, Alert, and Critical thresholds over time.")

    breach = {
        'Warning': (dfc['Vol']>dfc['Thr_Warning']).mean(),
        'Alert':   (dfc['Vol']>dfc['Thr_Alert']).mean(),
        'Critical':(dfc['Vol']>dfc['Thr_Critical']).mean()
    }
    st.bar_chart(pd.Series(breach, name='Breach Rate'))
    st.markdown("**Breach‚Äêrate bar**: percentage of days each tier would have flagged. Lower is fewer false alarms, higher is more coverage.")

# Base Regime Shifts
with tabs[2]:
    st.header(f"{base_cc} Regime Shifts")
    fig_b = px.line(df_base, x='Date', y='Vol', color='RegLabel',
                    labels={'Vol':'Daily Volatility'})
    for d in df_base.loc[chg_b,'Date']:
        fig_b.add_vline(x=d, line_dash='dash', line_color='red', opacity=0.6)
    fig_b.update_layout(title=f"{base_cc} Volatility by Regime")
    st.plotly_chart(fig_b, use_container_width=True)
    st.markdown("""
    This plot shows **daily volatility** of the base currency colored by its HMM‚Äêinferred regime.  
    Red dashed lines mark **regime change dates**, highlighting transitions between calm, normal, and stress periods.
    """)

# Quote Regime Shifts
with tabs[3]:
    st.header(f"{quote_cc} Regime Shifts")
    fig_q = px.line(df_quote, x='Date', y='Vol', color='RegLabel',
                    labels={'Vol':'Daily Volatility'})
    for d in df_quote.loc[chg_q,'Date']:
        fig_q.add_vline(x=d, line_dash='dash', line_color='green', opacity=0.6)
    fig_q.update_layout(title=f"{quote_cc} Volatility by Regime")
    st.plotly_chart(fig_q, use_container_width=True)
    st.markdown("""
    Same for the **quote currency**.  
    Green dashed lines mark where its regime shifted, so you can see if base vs. quote drives cross behavior.
    """)

# Cross Regime Shifts
with tabs[4]:
    st.header(f"{base_cc}/{quote_cc} Cross Regime Shifts")
    fig_x = px.line(df_cross, x='Date', y='Vol', color='RegLabel',
                    labels={'Vol':'Daily Volatility'})
    # cross changes
    for d in df_cross.loc[chg_x,'Date']:
        fig_x.add_vline(x=d, line_dash='dash', line_color='black', opacity=0.6)
    # overlay base & quote changes
    for d in df_base.loc[chg_b & df_base.Date.isin(df_cross.Date),'Date']:
        fig_x.add_vline(x=d, line_dash='dot', line_color='red',   opacity=0.4)
    for d in df_quote.loc[chg_q & df_quote.Date.isin(df_cross.Date),'Date']:
        fig_x.add_vline(x=d, line_dash='dot', line_color='green', opacity=0.4)
    fig_x.add_trace(go.Scatter(x=[None],y=[None],mode='lines',
        line=dict(color='red', dash='dot'), name=f"{base_cc} Reg Change"))
    fig_x.add_trace(go.Scatter(x=[None],y=[None],mode='lines',
        line=dict(color='green', dash='dot'), name=f"{quote_cc} Reg Change"))
    fig_x.update_layout(title=f"{base_cc}/{quote_cc} Cross Volatility by Regime")
    st.plotly_chart(fig_x, use_container_width=True)
    st.markdown("""
    The **cross** plot shows volatility colored by its regime (black dashed = cross changes).  
    Red/green dotted lines overlay the exact dates when the **base** or **quote** currencies changed regime, illustrating which leg drove the move.
    """)
