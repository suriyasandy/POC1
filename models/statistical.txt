import numpy as np
import pandas as pd
from arch import arch_model
from scipy.stats import genpareto

# Business‐defined manual bands on **daily** realized volatility
SQRT252 = np.sqrt(252)
ANNUAL_BOUNDS = {
    'Low':       (0.00, 0.07),
    'Medium':    (0.07, 0.50),
    'High':      (0.50, 0.60),
    'Very High': (0.60, None)
}

def rolling_quantile_thresholds(
    df: pd.DataFrame,
    vol_col: str = 'Volatility',
    window: int = 60,
    low_q: float = 0.05,
    high_q: float = 0.95
) -> pd.DataFrame:
    """
    Dynamic rolling quantile bands.
    """
    out = df.copy()
    out['Threshold_Low']  = out[vol_col].rolling(window).quantile(low_q)
    out['Threshold_High'] = out[vol_col].rolling(window).quantile(high_q)
    return out

def garch_evt_threshold(
    df: pd.DataFrame,
    return_col: str = 'LogReturn',
    tail_pct: float = 0.995
) -> float:
    """
    GARCH(1,1) + EVT tail‐risk threshold.
    """
    rets = df[return_col].dropna().values * 100.0
    am  = arch_model(rets, vol='Garch', p=1, q=1)
    res = am.fit(disp='off')

    std_resid = (res.resid / res.conditional_volatility)
    std_resid = std_resid[~np.isnan(std_resid)]

    u       = np.quantile(std_resid, 0.90)
    exceed  = std_resid[std_resid > u] - u
    c, loc, scale = genpareto.fit(exceed, floc=0)

    p_exceed = np.mean(std_resid > u)
    p_exc    = (tail_pct - (1 - p_exceed)) / p_exceed
    var_exc  = genpareto.ppf(p_exc, c, loc=0, scale=scale)
    var      = u + var_exc

    # Return threshold in same units as df[vol_col]
    return var / 100.0

def compute_manual_thresholds(
    df: pd.DataFrame,
    currency_col: str = 'Currency',
    vol_col: str = 'Volatility'
) -> (pd.DataFrame, pd.DataFrame):
    """
    Manual threshold calc:
      1) Realized daily vol = vol_col / sqrt(252)
      2) Mean per currency
      3) Assign group by ANNUAL_BOUNDS
      4) Group threshold = max(mean_vol) per group
    Returns:
      - mean_vol_df: [Currency, MeanVol, Group]
      - group_thr_df: [Group, Threshold]
    """
    df2 = df.copy()
    df2['Vol_Daily'] = df2[vol_col] / SQRT252
    # mean daily vol
    mean_vol = df2.groupby(currency_col)['Vol_Daily'] \
                  .mean() \
                  .reset_index(name='MeanVol')

    # assign group
    def assign_group(x):
        for grp,(low,high) in ANNUAL_BOUNDS.items():
            if high is None:
                if x >= low:
                    return grp
            elif x >= low and x < high:
                return grp
        return None

    mean_vol['Group'] = mean_vol['MeanVol'].apply(assign_group)

    # threshold per group = max MeanVol
    group_thr = mean_vol.groupby('Group')['MeanVol'] \
                       .max() \
                       .reset_index(name='Threshold')

    return mean_vol, group_thr

def get_manual_threshold_cross(
    mean_vol_df: pd.DataFrame,
    group_thr_df: pd.DataFrame,
    curr1: str,
    curr2: str
) -> float:
    """
    For a cross of curr1/curr2:
      - if both in same group → that group's threshold
      - else → higher threshold (wider vol)
    """
    grp1 = mean_vol_df.loc[mean_vol_df['Currency'] == curr1,'Group'].iloc[0]
    grp2 = mean_vol_df.loc[mean_vol_df['Currency'] == curr2,'Group'].iloc[0]

    if grp1 == grp2:
        return group_thr_df.loc[group_thr_df['Group']==grp1,'Threshold'].iloc[0]

    # pick higher group by defined order
    order = ['Low','Medium','High','Very High']
    idx1, idx2 = order.index(grp1), order.index(grp2)
    chosen = grp1 if idx1 > idx2 else grp2
    return group_thr_df.loc[group_thr_df['Group']==chosen,'Threshold'].iloc[0]
