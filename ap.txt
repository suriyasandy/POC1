# app.py

import streamlit as st
import pandas as pd
import numpy as np
import itertools
import plotly.graph_objects as go
import plotly.express as px
from arch import arch_model
from scipy.stats import genpareto

# ────────────────────────────────────────────────────────────────────────────────
# 1) UTILITY FUNCTIONS
# ────────────────────────────────────────────────────────────────────────────────

SQRT252 = np.sqrt(252)
MANUAL_BANDS = {
    'Low':       (0.00, 0.07),
    'Medium':    (0.07, 0.50),
    'High':      (0.50, 0.60),
    'Very High': (0.60, None)
}

def compute_manual_groups(df):
    df2 = df.copy()
    df2['DailyVol'] = df2['OHLCVolatility'] / SQRT252
    mean_vol = (df2.groupby('Currency')['DailyVol']
                  .mean().reset_index(name='MeanDailyVol'))
    def assign_band(v):
        for band,(low,high) in MANUAL_BANDS.items():
            if high is None:
                if v >= low: return band
            elif low <= v < high:
                return band
        return None
    mean_vol['Band'] = mean_vol['MeanDailyVol'].map(assign_band)
    band_thr = (mean_vol.groupby('Band')['MeanDailyVol']
                      .max().reset_index(name='BandThreshold'))
    return mean_vol, band_thr

def build_crosses(df):
    piv_c = df.pivot(index='Date', columns='Currency', values='Close')
    piv_v = df.pivot(index='Date', columns='Currency', values='OHLCVolatility')
    crosses = []
    codes = sorted(df['Currency'].unique())
    for i, base in enumerate(codes):
        for quote in codes[i+1:]:
            rate = piv_c[quote] / piv_c[base]
            vol  = np.sqrt(piv_v[base]**2 + piv_v[quote]**2)
            lr   = np.log(rate / rate.shift(1))
            tmp = pd.DataFrame({
                'Date': rate.index,
                'Cross': f"{base}/{quote}",
                'Close': rate.values,
                'Volatility': vol.values,
                'LogReturn': lr.values
            }).dropna()
            crosses.append(tmp)
    return pd.concat(crosses, ignore_index=True)

def rolling_quantile_thr(vol, window, q=0.95):
    return vol.rolling(window).quantile(q)

def garch_evt_thr(returns, tail_pct=0.995):
    res = arch_model(returns*100, vol='Garch', p=1, q=1).fit(disp='off')
    std = (res.resid / res.conditional_volatility).dropna()
    u = np.quantile(std, 0.90)
    exceed = std[std>u] - u
    c, loc, scale = genpareto.fit(exceed, floc=0)
    p_exc = (tail_pct - (1 - np.mean(std>u))) / np.mean(std>u)
    var_exc = genpareto.ppf(p_exc, c, loc=0, scale=scale)
    return (u + var_exc)/100

# ────────────────────────────────────────────────────────────────────────────────
# 2) STREAMLIT UI SETUP
# ────────────────────────────────────────────────────────────────────────────────

st.set_page_config(page_title="FX Thresholding PoC", layout="wide")
st.title("FX Volatility Thresholding — Manual vs. Dynamic")

# — Sidebar —
st.sidebar.header("1) Upload & Settings")
f = st.sidebar.file_uploader(
    "Upload consolidated FX CSV\n(Date,Open,High,Low,Close,OHLCVolatility,Currency)",
    type="csv"
)
if not f:
    st.sidebar.info("Please upload your FX data.")
    st.stop()

df_all = pd.read_csv(f, parse_dates=['Date']).sort_values('Date')

# Manual groups
mean_vol_df, band_thr_df = compute_manual_groups(df_all)

# Synthetic crosses
cross_df = build_crosses(df_all)
cross_list = sorted(cross_df['Cross'].unique())
sel_cross = st.sidebar.selectbox("Select Cross", cross_list)

# Dynamic threshold params
st.sidebar.header("2) Dynamic Threshold Settings")
rq_w  = st.sidebar.slider("Rolling Window (days)", 30,120,60)
evt_p = st.sidebar.slider("EVT Tail Percentile", 0.990,0.999,0.995,0.001)

# Consensus fraction (for calibration & optional use)
cons_t = st.sidebar.slider("Consensus Fraction",0.1,1.0,0.5,0.05)

# — Filter for selected cross —
dfc = cross_df.query("Cross == @sel_cross").reset_index(drop=True)

# Manual threshold for this cross
base, quote = sel_cross.split('/')
b1 = mean_vol_df.loc[mean_vol_df.Currency==base,'Band'].iat[0]
b2 = mean_vol_df.loc[mean_vol_df.Currency==quote,'Band'].iat[0]
order = ['Low','Medium','High','Very High']
man_band = b1 if order.index(b1)>order.index(b2) else b2
man_thr = band_thr_df.loc[band_thr_df.Band==man_band,'BandThreshold'].iat[0]

# Compute dynamic thresholds
dfc['Roll95'] = rolling_quantile_thr(dfc['Volatility'], rq_w, q=0.95)
evt_thr = garch_evt_thr(dfc['LogReturn'].values, tail_pct=evt_p)

# Compute breach flags
dfc['Breach_Manual'] = (dfc['Volatility'] > man_thr).astype(int)
dfc['Breach_Roll95']= (dfc['Volatility'] > dfc['Roll95']).astype(int)
dfc['Breach_EVT']    = (dfc['Volatility'] > evt_thr).astype(int)
dfc['Breach_Cons']   = ((dfc[['Breach_Roll95','Breach_EVT']].mean(axis=1) 
                        >= cons_t).astype(int))

# Aggregate daily breach rates
rates = dfc.set_index('Date')[
    ['Breach_Manual','Breach_Roll95','Breach_EVT','Breach_Cons']
].rename(columns={
    'Breach_Manual':'Manual',
    'Breach_Roll95':'Rolling 95%',
    'Breach_EVT':'EVT',
    'Breach_Cons':'Consensus'
})

# ────────────────────────────────────────────────────────────────────────────────
# 3) TABS: Overview, Results, Calibration
# ────────────────────────────────────────────────────────────────────────────────

tab1, tab2, tab3 = st.tabs([
    "📝 Overview",
    "📊 Results & Visuals",
    "⚙️ Calibration"
])

with tab1:
    st.header("How Our Thresholding Works")
    st.markdown("""
    **Manual Bands**  
    - Convert annualized OHLC vol → _daily_ vol (÷√252).  
    - Compute mean daily vol per currency → bucket into **Low/Medium/High/Very High**.  
    - Each band’s threshold = **max** mean-daily-vol in that band (static).

    **Dynamic Rolling-Quantile**  
    - 95th percentile of daily vol over a sliding window (e.g., 60 days).  
    - Adapts to changing volatility regimes.

    **EVT Tail-Risk**  
    - Fit a GARCH(1,1) on returns → extract standardized residuals.  
    - Model the upper tail with a GPD → derive ~99.5th-percentile “VaR.”

    **Consensus (Optional)**  
    - Final breach if ≥ _fraction_ of {Rolling, EVT} signals align.

    **Use This PoC** to compare **Manual vs. Dynamic vs. EVT** thresholds on any FX cross—**no coding** needed.
    """)

with tab2:
    st.header(f"Threshold Comparison for {sel_cross}")

    # Manual bands bar
    fig0 = px.bar(
        mean_vol_df,
        x='Currency', y='MeanDailyVol', color='Band',
        title="Mean Daily Vol by Currency (Manual Bands)",
        labels={'MeanDailyVol':'Mean Daily Vol'}
    )
    st.plotly_chart(fig0, use_container_width=True)

    st.markdown(f"**Selected cross manual band:** **{man_band}**, threshold = **{man_thr:.4f}**")

    # KPI cards
    c1,c2,c3,c4 = st.columns(4)
    c1.metric("Manual Thr",    f"{man_thr:.4f}")
    c2.metric("Rolling 95% Thr", f"{dfc['Roll95'].iat[-1]:.4f}")
    c3.metric("EVT Tail Thr",    f"{evt_thr:.4f}")
    c4.metric("Consensus Frac.", f"{cons_t:.2f}")

    st.markdown("---")

    # Overlay thresholds
    st.markdown("#### Volatility & Selected Thresholds")
    opts = ["Manual","Rolling 95%","EVT","Consensus"]
    sel = st.multiselect("Overlay:", opts, default=["Manual","Rolling 95%","EVT"])

    fig1 = go.Figure()
    fig1.add_trace(go.Scatter(x=dfc['Date'], y=dfc['Volatility'], name='Volatility'))
    style = {
        "Manual":      dict(y=[man_thr]*len(dfc),         line=dict(dash='dash',color='black')),
        "Rolling 95%": dict(y=dfc['Roll95'],              line=dict(dash='dot',color='orange')),
        "EVT":         dict(y=[evt_thr]*len(dfc),         line=dict(dash='longdash',color='green')),
        "Consensus":   dict(y=[cons_t]*len(dfc),          line=dict(dash='dashdot',color='purple'))
    }
    for key in sel:
        fig1.add_trace(go.Scatter(
            x=dfc['Date'], y=style[key]['y'],
            name=key, line=style[key]['line']
        ))
    fig1.update_layout(xaxis=dict(rangeslider=dict(visible=True)), height=450)
    st.plotly_chart(fig1, use_container_width=True)

    st.markdown("---")

    # Daily breach rates
    st.markdown("#### Daily Breach Rates")
    fig2 = go.Figure()
    for col in rates.columns:
        fig2.add_trace(go.Scatter(x=rates.index, y=rates[col], name=col))
    fig2.update_layout(xaxis=dict(rangeslider=dict(visible=True)), height=350)
    st.plotly_chart(fig2, use_container_width=True)

    # Summary table
    summary = rates.mean().rename("Avg Breach Rate").to_frame()
    st.table(summary.style.format("{:.1%}"))

    st.markdown(f"""
    **Interpretation:**  
    - **Manual** flags {summary.loc['Manual','Avg Breach Rate']:.1%} of days.  
    - **Rolling 95%** flags {summary.loc['Rolling 95%','Avg Breach Rate']:.1%} of days.  
    - **EVT** flags {summary.loc['EVT','Avg Breach Rate']:.1%} of days.  
    - **Consensus** flags {summary.loc['Consensus','Avg Breach Rate']:.1%} of days.
    """)

with tab3:
    st.header("⚙️ Hyperparameter Calibration")
    st.markdown("Sweep Rolling‐window & EVT percentile to see breach‐rate trade‐offs.")

    windows = [30,60,90,120]
    evts    = [0.990,0.995,0.999]
    calib = []
    for w,e in itertools.product(windows, evts):
        # rolling
        r95 = rolling_quantile_thr(dfc['Volatility'], w, q=0.95)
        br_r = (dfc['Volatility']>r95).mean()
        # evt
        br_e = (dfc['Volatility']>garch_evt_thr(dfc['LogReturn'].values, tail_pct=e)).mean()
        # consensus
        br_c = (((dfc['Volatility']>r95).astype(int) +
                 (dfc['Volatility']>garch_evt_thr(dfc['LogReturn'].values,e)).astype(int)
                )/2 >= cons_t).mean()
        calib.append({
            'Window': w, 'EVT Pct': e,
            'Manual': rates['Manual'].mean(),
            'Rolling 95%': br_r,
            'EVT': br_e,
            'Consensus': br_c
        })
    calib_df = pd.DataFrame(calib)

    # Rolling heatmap
    roll_pvt = calib_df.pivot('Window','EVT Pct','Rolling 95%')
    st.markdown("##### Rolling-Only Breach Rate")
    fig_r = px.imshow(
        roll_pvt, labels=dict(x="EVT %", y="Window", color="Breach Rate"),
        text_auto=".1%", aspect="auto"
    )
    st.plotly_chart(fig_r, use_container_width=True)

    # EVT heatmap
    evt_pvt = calib_df.pivot('Window','EVT Pct','EVT')
    st.markdown("##### EVT-Only Breach Rate")
    fig_e = px.imshow(
        evt_pvt, labels=dict(x="EVT %", y="Window", color="Breach Rate"),
        text_auto=".1%", aspect="auto"
    )
    st.plotly_chart(fig_e, use_container_width=True)

    # Compare at chosen params
    st.markdown("##### At Your Chosen Params")
    sel_row = calib_df[(calib_df.Window==rq_w)&(calib_df['EVT Pct']==evt_p)].iloc[0]
    cmp = pd.DataFrame({
        'Method':['Manual','Rolling 95%','EVT','Consensus'],
        'BreachRate':[sel_row.Manual, sel_row['Rolling 95%'], sel_row.EVT, sel_row.Consensus]
    })
    fig_c = px.bar(
        cmp, x='Method', y='BreachRate', text=cmp['BreachRate'].map("{:.1%}".format),
        title=f"Breach Rates @ Window={rq_w}, EVT={evt_p}"
    )
    fig_c.update_layout(yaxis_tickformat=".0%", yaxis_title="Avg Breach Rate")
    st.plotly_chart(fig_c, use_container_width=True)
