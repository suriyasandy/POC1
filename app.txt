import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go

from features import build_feature_matrix
from models.statistical import rolling_quantile_thresholds, garch_evt_threshold
from models.ml import run_isolation_forest, run_one_class_svm, run_autoencoder
from models.ensemble import compute_consensus
from models.backtest import simulate_trades, apply_trade_flags, aggregate_backtest_metrics

st.set_page_config(page_title="FX Volatility Threshold Monitoring", layout="wide")

# Sidebar
with st.sidebar:
    st.header("Upload & Settings")
    uploaded_file = st.file_uploader("Upload FX data (CSV)", type="csv")
    n_trades      = st.slider("Simulated Trades/Day", 10, 200, 50)

if not uploaded_file:
    st.warning("Please upload a CSV with: Date, Open, High, Low, Close, Volatility")
    st.stop()

# Load & Feature-building
df_raw = pd.read_csv(uploaded_file, parse_dates=['Date'])
df      = build_feature_matrix(df_raw)

# Tabs
tab_overview, tab_stat, tab_ml, tab_consensus, tab_backtest, tab_impact = st.tabs([
    "📋 Overview",
    "📊 Statistical",
    "🤖 ML Models",
    "🤝 Consensus",
    "📈 Backtest",
    "📊 Impact Analysis"
])

# — Overview —
with tab_overview:
    st.title("FX Volatility Threshold Monitoring")
    # KPI Cards
    df_stat = rolling_quantile_thresholds(df[['Date','Volatility']].copy(), window=60, low_q=0.05, high_q=0.95)
    df_cons = pd.DataFrame()  # will fill later
    current_vol = df_stat['Volatility'].iloc[-1]
    upper_thr   = df_stat['Threshold_High'].iloc[-1]
    # placeholder for consensus
    c1, c2, c3 = st.columns(3)
    c1.metric("Current Volatility", f"{current_vol:.3f}", delta=f"{(current_vol/upper_thr-1)*100:.1f}%")
    c2.metric("Upper Threshold", f"{upper_thr:.3f}")
    c3.metric("Consensus Breach Rate", "—")

    st.markdown("""
    **Purpose:** Dynamically detect FX volatility breaches  
    **Workflow:**  
    1. Statistical (rolling‐quantile & GARCH‐EVT)  
    2. ML (Isolation Forest, SVM, Autoencoder)  
    3. Consensus voting  
    4. Trade‐level backtesting  

    ### Why Dynamic vs. Manual  
    - **Manual:** static bands → misses regime shifts  
    - **Dynamic:** re-calibrated monthly, responsive to tail events, aligned with business risk tolerance
    """)

# — Statistical —
with tab_stat:
    st.subheader("Statistical Thresholds")
    rq_w   = st.slider("Window (days)", 30, 120, 60)
    rq_l, rq_h = st.slider("Low/High Quantiles", 0.01, 0.10, (0.05, 0.95))
    evt_p  = st.slider("EVT Tail %ile", 0.990, 0.999, 0.995, step=0.001)

    df_stat = df[['Date','Volatility']].copy()
    df_stat = rolling_quantile_thresholds(df_stat, window=rq_w, low_q=rq_l, high_q=rq_h)
    evt_thr = garch_evt_threshold(df, tail_pct=evt_p)

    fig = go.Figure([
        go.Scatter(x=df_stat['Date'], y=df_stat['Volatility'], name='Volatility'),
        go.Scatter(x=df_stat['Date'], y=df_stat['Threshold_High'],
                   name=f'{int(rq_h*100)}% Upper', line=dict(dash='dash')),
        go.Scatter(x=df_stat['Date'], y=df_stat['Threshold_Low'],
                   name=f'{int(rq_l*100)}% Lower', line=dict(dash='dot')),
        go.Scatter(x=df_stat['Date'], y=[evt_thr]*len(df_stat),
                   name=f'EVT {evt_p}', line=dict(color='green', dash='dash'))
    ])
    fig.update_layout(
        xaxis=dict(rangeslider=dict(visible=True),
                   rangeselector=dict(buttons=[
                       dict(count=1, label="1m", step="month", stepmode="backward"),
                       dict(count=3, label="3m", step="month", stepmode="backward"),
                       dict(step="all")
                   ])),
        yaxis_title="Annualized Volatility", height=500
    )
    st.plotly_chart(fig, use_container_width=True)
    st.markdown(f"**EVT Threshold:** {evt_thr:.4f}")

# — ML Models —
with tab_ml:
    st.subheader("ML Anomaly Detection")
    cont_if = st.slider("IF Contamination", 0.01, 0.10, 0.05, step=0.005)
    nu_svm  = st.slider("SVM ν",            0.01, 0.10, 0.05, step=0.005)
    ae_tail = st.slider("AE Tail %ile",     0.90, 0.99, 0.95, step=0.01)

    feats = [c for c in df.columns if any(x in c for x in ['Volatility','LogReturn','RSI','BB_','MACD'])]
    X     = df[feats].fillna(method='ffill').dropna()
    df_ml = df.loc[X.index, ['Date','Volatility']].copy()

    df_ml['IF_Anomaly']  = run_isolation_forest(X.values, contamination=cont_if)
    df_ml['SVM_Anomaly'] = run_one_class_svm(X.values, nu=nu_svm)
    ae_mse = run_autoencoder(X.values)
    ae_thr = np.quantile(ae_mse, ae_tail)
    df_ml['AE_Anomaly']  = (ae_mse > ae_thr).astype(int)

    # Hyperparam tuning expander
    with st.expander("🔧 Hyperparameter Tuning", expanded=False):
        manual_rate = (df_stat['Volatility'] > df_stat['Threshold_High']).mean()
        cont_grid = np.round(np.linspace(0.01,0.10,10),3)
        rates_if = [(c, run_isolation_forest(X.values, contamination=c).mean()) for c in cont_grid]
        df_if    = pd.DataFrame(rates_if, columns=["contamination","anomaly_rate"])
        fig_if   = px.line(df_if, x="contamination", y="anomaly_rate",
                           title="IF Contamination vs. Anomaly Rate",
                           labels={"anomaly_rate":"Rate","contamination":"Contamination"})
        fig_if.add_hline(y=manual_rate, line_dash="dash", annotation_text="Manual Breach Rate")
        st.plotly_chart(fig_if, use_container_width=True)

        nu_grid   = np.round(np.linspace(0.01,0.10,10),3)
        rates_svm = [(n, run_one_class_svm(X.values, nu=n).mean()) for n in nu_grid]
        df_svm    = pd.DataFrame(rates_svm, columns=["nu","anomaly_rate"])
        fig_svm   = px.line(df_svm, x="nu", y="anomaly_rate",
                           title="SVM ν vs. Anomaly Rate",
                           labels={"anomaly_rate":"Rate","nu":"ν"})
        fig_svm.add_hline(y=manual_rate, line_dash="dash", annotation_text="Manual Breach Rate")
        st.plotly_chart(fig_svm, use_container_width=True)

        st.markdown("_Align ML rates to manual breach rate to calibrate to business tolerance._")

    st.markdown("**Anomaly Rates**")
    st.write({
        'IsolationForest': f"{df_ml['IF_Anomaly'].mean():.1%}",
        'OneClassSVM':     f"{df_ml['SVM_Anomaly'].mean():.1%}",
        'Autoencoder':     f"{df_ml['AE_Anomaly'].mean():.1%}"
    })

    fig2 = go.Figure([go.Scatter(x=df_ml['Date'], y=df_ml['Volatility'], name='Volatility')])
    for col, clr in [('IF_Anomaly','red'),('SVM_Anomaly','orange'),('AE_Anomaly','green')]:
        fig2.add_trace(go.Scatter(
            x=df_ml.loc[df_ml[col]==1,'Date'],
            y=df_ml.loc[df_ml[col]==1,'Volatility'],
            mode='markers', name=col,
            marker=dict(color=clr, size=6)
        ))
    fig2.update_layout(xaxis=dict(rangeslider=dict(visible=True)), height=500)
    st.plotly_chart(fig2, use_container_width=True)

# — Consensus —
with tab_consensus:
    st.subheader("Consensus Voting")
    cons_t  = st.slider("Consensus Threshold", 0.1, 1.0, 0.5, step=0.05)

    df_cons = pd.DataFrame({
        'Date': df_ml['Date'],
        'Volatility': df_ml['Volatility'],
        'Rolling': (df_stat.set_index('Date').loc[df_ml['Date'],'Volatility'] >
                    df_stat.set_index('Date')['Threshold_High']).astype(int),
        'IF':   df_ml['IF_Anomaly'],
        'SVM':  df_ml['SVM_Anomaly'],
        'AE':   df_ml['AE_Anomaly']
    }).reset_index(drop=True)

    flags = df_cons[['Rolling','IF','SVM','AE']]
    df_cons['Score'], df_cons['Breach'] = compute_consensus(flags, threshold=cons_t)

    # KPI & Agreement Heatmap
    c1, c2 = st.columns([2,3])
    c1.metric("Consensus Breach Rate", f"{df_cons['Breach'].mean():.1%}")
    agree_df = df_cons[['Rolling','IF','SVM','AE']].corr().round(2)
    fig_heat = px.imshow(agree_df, text_auto=True, title="Model Agreement Correlation")
    c2.plotly_chart(fig_heat, use_container_width=True)

    # Gauge
    latest_score = df_cons['Score'].iloc[-1]
    fig_gauge = go.Figure(go.Indicator(
        mode="gauge+number",
        value=latest_score,
        title={"text":"Latest Consensus Score"},
        gauge={"axis": {"range":[0,1]},
               "bar": {"color":"crimson"},
               "steps": [{"range":[0,cons_t],"color":"lightgray"},
                         {"range":[cons_t,1],"color":"lightcoral"}]}
    ))
    fig_gauge.update_layout(height=300)
    st.plotly_chart(fig_gauge, use_container_width=True)

# — Backtest —
with tab_backtest:
    st.subheader("Backtesting & Simulation")
    trades_flagged = apply_trade_flags(
        simulate_trades(df, n_trades_per_day=n_trades),
        df_stat, df_ml, evt_thr
    )
    metrics = aggregate_backtest_metrics(trades_flagged)

    st.markdown("**Daily Flag Rates**")
    st.dataframe(metrics[[c for c in metrics.columns if '_Rate' in c]])

    st.markdown("**Avg Deviation Impact**")
    st.line_chart(metrics[[c for c in metrics.columns if 'AvgDev' in c]])

    st.markdown("**Sample Trades & Why Flagged**")
    for _, row in trades_flagged.sample(3, random_state=42).iterrows():
        with st.expander(f"{row['Date'].date()} | Dev={row['Deviation']:.3f}"):
            reasons = []
            if row['Rolling_Flag']: reasons.append("Rolling breach")
            if row['EVT_Flag']:     reasons.append("EVT breach")
            if row['IF_Flag']:      reasons.append("IsolationForest")
            if row['SVM_Flag']:     reasons.append("OneClassSVM")
            if row['AE_Flag']:      reasons.append("Autoencoder")
            st.write(f"MarketRate: {row['MarketRate']:.4f}   DealRate: {row['DealRate']:.4f}")
            st.write("🔎 Reasons:", ", ".join(reasons))

# — Impact Analysis —
with tab_impact:
    st.header("Business Impact & ROI")

    # Cumulative risk proxy
    trades_flagged = apply_trade_flags(
        simulate_trades(df, n_trades_per_day=n_trades),
        df_stat, df_ml, evt_thr
    )
    daily_risk = trades_flagged.groupby("Date")['Deviation'].apply(lambda x: x.abs().sum())
    cum_risk   = daily_risk.cumsum()
    fig_risk   = go.Figure(go.Scatter(x=cum_risk.index, y=cum_risk.values, name="Cumulative Risk"))
    fig_risk.update_layout(title="Cumulative Deviation (Risk Proxy)", height=400)
    st.plotly_chart(fig_risk, use_container_width=True)

    # Flag rates comparison
    df_rates = pd.DataFrame({
        "Manual":    (df_stat['Volatility'] > df_stat['Threshold_High']).mean(),
        "IF":        df_ml['IF_Anomaly'].mean(),
        "SVM":       df_ml['SVM_Anomaly'].mean(),
        "AE":        df_ml['AE_Anomaly'].mean(),
        "Consensus": df_cons['Breach'].mean()
    }, index=["Flag Rate"]).T
    st.bar_chart(df_rates, height=300)

    st.markdown("""
    - **Reduced False Positives:** Dynamic bands adapt to regime shifts  
    - **Enhanced Tail Capture:** GARCH‐EVT for extreme events  
    - **Operational Efficiency:** Consensus voting automates alerts  
    """)

    # Export data & summary
    csv_trades = trades_flagged.to_csv(index=False)
    st.download_button("📥 Download Flagged Trades", csv_trades, "flagged_trades.csv")
